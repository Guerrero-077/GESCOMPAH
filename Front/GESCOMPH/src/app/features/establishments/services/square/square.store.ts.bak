import { Injectable, inject, signal, computed } from '@angular/core';
import { firstValueFrom } from 'rxjs';
import {
  SquareCreateModel,
  SquareSelectModel,
  SquareUpdateModel
} from '../../models/squares.models';
import { SquareService } from './square.service';

@Injectable({ providedIn: 'root' })
export class SquareStore {
  private readonly svc = inject(SquareService);

  // Estado base (UI)
  private readonly _items   = signal<SquareSelectModel[]>([]);
  private readonly _loading = signal(false);
  private readonly _error   = signal<string | null>(null);

  // Concurrencia por ítem (p. ej., toggle)
  private readonly _busyIds = signal<Set<number>>(new Set());

  // Selectores
  readonly items   = computed(() => this._items());
  readonly loading = computed(() => this._loading());
  readonly error   = computed(() => this._error());
  readonly count   = computed(() => this._items().length);
  readonly busyIds = computed(() => this._busyIds());

  isBusy(id: number): boolean {
    return this._busyIds().has(id);
  }

  // Helpers de colección
  setAll(list: SquareSelectModel[]): void {
    this._items.set(list ?? []);
  }

  /** Inserta/actualiza preservando orden actual (no reordena todo el array). */
  upsertMany(list: SquareSelectModel[]): void {
    if (!list?.length) return;
    const byId = new Map(list.map(it => [it.id, it]));
    this._items.update(arr => {
      const next = arr.map(it => byId.get(it.id) ?? it);
      // agrega los que no estaban
      byId.forEach((it, id) => {
        if (!arr.some(x => x.id === id)) next.unshift(it);
      });
      return next;
    });
  }

  upsertOne(item: SquareSelectModel): void {
    this._items.update(arr => {
      const i = arr.findIndex(x => x.id === item.id);
      if (i === -1) return [item, ...arr];
      const copy = arr.slice();
      copy[i] = item;
      return copy;
    });
  }

  patchOne(id: number, patch: Partial<SquareSelectModel>): void {
    this._items.update(arr => arr.map(x => x.id === id ? { ...x, ...patch } : x));
  }

  remove(id: number): void {
    this._items.update(arr => arr.filter(x => x.id !== id));
  }

  clear(): void {
    this._items.set([]);
    this._error.set(null);
    this._loading.set(false);
    this._busyIds.set(new Set());
  }

  changeActiveStatus(id: number, active: boolean): void {
    this.patchOne(id, { active });
  }

  getById(id: number): SquareSelectModel | undefined {
    return this._items().find(x => x.id === id);
  }

  private markBusy(id: number, val: boolean): void {
    this._busyIds.update(set => {
      const next = new Set(set);
      val ? next.add(id) : next.delete(id);
      return next;
    });
  }

  private setError(e: unknown): void {
    this._error.set(String((e as any)?.message ?? e ?? 'Error'));
  }

  // I/O
  async loadAll(): Promise<void> {
    this._loading.set(true);
    this._error.set(null);
    try {
      const data = await firstValueFrom(this.svc.getAll());
      this.setAll(data ?? []);
    } catch (e) {
      this.setError(e);
    } finally {
      this._loading.set(false);
    }
  }

  async create(dto: SquareCreateModel): Promise<void> {
    try {
      const created = await firstValueFrom(this.svc.create(dto));
      this.upsertOne(created);
    } catch (e) {
      this.setError(e);
      throw e;
    }
  }

  async update(id: number, dto: SquareUpdateModel): Promise<void> {
    try {
      const updated = await firstValueFrom(this.svc.update(id, dto));
      this.upsertOne(updated);
    } catch (e) {
      this.setError(e);
      throw e;
    }
  }

  async delete(id: number): Promise<void> {
    try {
      await firstValueFrom(this.svc.delete(id));
      this.remove(id);
    } catch (e) {
      this.setError(e);
      throw e;
    }
  }

  async deleteLogic(id: number): Promise<void> {
    try {
      await firstValueFrom(this.svc.deleteLogic(id));
      // NOTA: si tu backend hace "soft delete" (p. ej. active=false),
      // y quieres seguir viéndola como inactiva, en lugar de remove(id)
      // podrías hacer: this.changeActiveStatus(id, false);
      this.remove(id);
    } catch (e) {
      this.setError(e);
      throw e;
    }
  }

  /** Toggle remoto (optimista + rollback). */
  async changeActiveStatusRemote(id: number, active: boolean): Promise<{ ok: boolean; message?: string }> {
    if (this.isBusy(id)) return; // evita doble clic
    const prev = this.getById(id)?.active; // true/false/undefined
    this.markBusy(id, true);
    this.changeActiveStatus(id, active); // optimista

    try {
      const updated: any = await firstValueFrom(this.svc.changeActiveStatus(id, active));
      // Si backend devolvió un envelope de error controlado (200 OK)
      if (updated && typeof updated === 'object' && updated.success === false) {
        // rollback y lanza error para que el UI lo maneje como alerta
        if (prev !== undefined) this.changeActiveStatus(id, prev);
        return { ok: false, message: updated.message || 'No se pudo cambiar el estado.' };
      }
      if (updated) this.upsertOne(updated as any);
    } catch (err) {
      if (prev !== undefined) this.changeActiveStatus(id, prev); // rollback
      const msg = (err as any)?.error?.detail || (err as any)?.error?.message || (err as any)?.message;
      return { ok: false, message: msg || 'No se pudo cambiar el estado.' };
    } finally {
      this.markBusy(id, false);
    }
  }
  }
}






