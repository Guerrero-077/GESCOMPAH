import { Component, Input, Output, EventEmitter, OnInit, OnDestroy } from '@angular/core';
import { FormBuilder, FormGroup, Validators, ReactiveFormsModule } from '@angular/forms';
import { CommonModule } from '@angular/common';
import { MatFormFieldModule } from '@angular/material/form-field';
import { MatInputModule } from '@angular/material/input';
import { MatButtonModule } from '@angular/material/button';
import { MatSelectModule } from '@angular/material/select';
import { MatCheckboxModule } from '@angular/material/checkbox';
import { MatDatepickerModule } from '@angular/material/datepicker';
import { MatNativeDateModule } from '@angular/material/core';
import { Subject, takeUntil } from 'rxjs';
import { DynamicFormConfig, DynamicFormField } from '../../Models/Form/form.models';

@Component({
  selector: 'app-dynamic-form-component',
  standalone: true,
  imports: [
    CommonModule,
    ReactiveFormsModule,
    MatFormFieldModule,
    MatInputModule,
    MatButtonModule,
    MatSelectModule,
    MatCheckboxModule,
    MatDatepickerModule,
    MatNativeDateModule
  ],
  template: `
    <form [formGroup]="dynamicForm" (ngSubmit)="onSubmit()" class="dynamic-form">
      
      <div *ngFor="let field of config.fields" class="form-field">
        
        <!-- Text Input -->
        <mat-form-field 
          *ngIf="field.type === 'text' || field.type === 'email' || field.type === 'password'"
          [appearance]="field.appearance || 'fill'"
          class="full-width">
          <mat-label>{{ field.label }}</mat-label>
          <input 
            matInput 
            [formControlName]="field.name"
            [type]="field.type"
            [placeholder]="field.placeholder || ''"
            [readonly]="field.readonly || false">
          <mat-error *ngIf="getFieldError(field.name)">
            {{ getFieldErrorMessage(field.name, field) }}
          </mat-error>
        </mat-form-field>

        <!-- Number Input -->
        <mat-form-field 
          *ngIf="field.type === 'number'"
          [appearance]="field.appearance || 'fill'"
          class="full-width">
          <mat-label>{{ field.label }}</mat-label>
          <input 
            matInput 
            type="number"
            [formControlName]="field.name"
            [placeholder]="field.placeholder || ''"
            [readonly]="field.readonly || false">
          <mat-error *ngIf="getFieldError(field.name)">
            {{ getFieldErrorMessage(field.name, field) }}
          </mat-error>
        </mat-form-field>

        <!-- Textarea -->
        <mat-form-field 
          *ngIf="field.type === 'textarea'"
          [appearance]="field.appearance || 'fill'"
          class="full-width">
          <mat-label>{{ field.label }}</mat-label>
          <textarea 
            matInput
            [formControlName]="field.name"
            [placeholder]="field.placeholder || ''"
            [rows]="field.rows || 3"
            [readonly]="field.readonly || false">
          </textarea>
          <mat-error *ngIf="getFieldError(field.name)">
            {{ getFieldErrorMessage(field.name, field) }}
          </mat-error>
        </mat-form-field>

        <!-- Select -->
        <mat-form-field 
          *ngIf="field.type === 'select'"
          [appearance]="field.appearance || 'fill'"
          class="full-width">
          <mat-label>{{ field.label }}</mat-label>
          <mat-select 
            [formControlName]="field.name"
            [placeholder]="field.placeholder || ''">
            <mat-option *ngFor="let option of field.options" [value]="option.value">
              {{ option.label }}
            </mat-option>
          </mat-select>
          <mat-error *ngIf="getFieldError(field.name)">
            {{ getFieldErrorMessage(field.name, field) }}
          </mat-error>
        </mat-form-field>

        <!-- Checkbox -->
        <div *ngIf="field.type === 'checkbox'" class="checkbox-field">
          <mat-checkbox 
            [formControlName]="field.name"
            [color]="'primary'">
            {{ field.label }}
          </mat-checkbox>
        </div>

        <!-- Date -->
        <mat-form-field 
          *ngIf="field.type === 'date'"
          [appearance]="field.appearance || 'fill'"
          class="full-width">
          <mat-label>{{ field.label }}</mat-label>
          <input 
            matInput 
            [matDatepicker]="picker"
            [formControlName]="field.name"
            [placeholder]="field.placeholder || ''"
            [readonly]="field.readonly || false">
          <mat-datepicker-toggle matSuffix [for]="picker"></mat-datepicker-toggle>
          <mat-datepicker #picker></mat-datepicker>
          <mat-error *ngIf="getFieldError(field.name)">
            {{ getFieldErrorMessage(field.name, field) }}
          </mat-error>
        </mat-form-field>

      </div>

      <!-- Submit Button -->
      <div *ngIf="showSubmitButton" class="form-actions">
        <button 
          mat-raised-button 
          color="primary" 
          type="submit"
          [disabled]="dynamicForm.invalid || isSubmitting"
          class="submit-button">
          {{ isSubmitting ? 'Procesando...' : (config.submitButtonLabel || 'Enviar') }}
        </button>
      </div>

    </form>
  `,
  styles: [`
    .dynamic-form {
      display: flex;
      flex-direction: column;
      gap: 16px;
      width: 100%;
    }

    .form-field {
      width: 100%;
    }

    .full-width {
      width: 100%;
    }

    .checkbox-field {
      margin: 8px 0;
    }

    .form-actions {
      display: flex;
      justify-content: flex-end;
      margin-top: 16px;
      padding-top: 16px;
      border-top: 1px solid #e0e0e0;
    }

    .submit-button {
      min-width: 120px;
      height: 40px;
    }

    /* Responsive */
    @media (max-width: 768px) {
      .form-actions {
        justify-content: stretch;
      }
      
      .submit-button {
        width: 100%;
      }
    }
  `]
})
export class DynamicFormComponent implements OnInit, OnDestroy {
  @Input() config!: DynamicFormConfig;
  @Input() showSubmitButton: boolean = true;
  @Output() formSubmit = new EventEmitter<any>();
  @Output() formDataChange = new EventEmitter<any>();

  dynamicForm!: FormGroup;
  isSubmitting = false;
  private destroy$ = new Subject<void>();

  constructor(private fb: FormBuilder) {}

  ngOnInit(): void {
    this.buildForm();
    this.setupFormSubscription();
  }

  ngOnDestroy(): void {
    this.destroy$.next();
    this.destroy$.complete();
  }

  private buildForm(): void {
    const formControls: { [key: string]: any } = {};

    this.config.fields.forEach(field => {
      const validators = this.buildValidators(field);
      const initialValue = this.getInitialValue(field);
      
      formControls[field.name] = [initialValue, validators];
    });

    this.dynamicForm = this.fb.group(formControls);
  }

  private setupFormSubscription(): void {
    this.dynamicForm.valueChanges
      .pipe(takeUntil(this.destroy$))
      .subscribe(value => {
        this.formDataChange.emit(value);
      });
  }

  private buildValidators(field: DynamicFormField): any[] {
    const validators: any[] = [];

    if (field.validations) {
      if (field.validations.required) {
        validators.push(Validators.required);
      }
      if (field.validations.minLength) {
        validators.push(Validators.minLength(field.validations.minLength));
      }
      if (field.validations.maxLength) {
        validators.push(Validators.maxLength(field.validations.maxLength));
      }
      if (field.validations.min) {
        validators.push(Validators.min(field.validations.min));
      }
      if (field.validations.max) {
        validators.push(Validators.max(field.validations.max));
      }
      if (field.validations.email) {
        validators.push(Validators.email);
      }
      if (field.validations.pattern) {
        validators.push(Validators.pattern(field.validations.pattern));
      }
    }

    return validators;
  }

  private getInitialValue(field: DynamicFormField): any {
    switch (field.type) {
      case 'checkbox':
        return field.value || false;
      case 'number':
        return field.value || null;
      case 'date':
        return field.value ? new Date(field.value) : null;
      default:
        return field.value || '';
    }
  }

  getFieldError(fieldName: string): boolean {
    const field = this.dynamicForm.get(fieldName);
    return !!(field && field.errors && (field.dirty || field.touched));
  }

  getFieldErrorMessage(fieldName: string, field: DynamicFormField): string {
    const control = this.dynamicForm.get(fieldName);
    if (!control || !control.errors) return '';

    const errors = control.errors;

    if (errors['required']) {
      return `${field.label} es requerido`;
    }
    if (errors['minlength']) {
      return `${field.label} debe tener al menos ${errors['minlength'].requiredLength} caracteres`;
    }
    if (errors['maxlength']) {
      return `${field.label} no puede tener más de ${errors['maxlength'].requiredLength} caracteres`;
    }
    if (errors['min']) {
      return `${field.label} debe ser mayor o igual a ${errors['min'].min}`;
    }
    if (errors['max']) {
      return `${field.label} debe ser menor o igual a ${errors['max'].max}`;
    }
    if (errors['email']) {
      return `${field.label} debe tener un formato válido`;
    }
    if (errors['pattern']) {
      return `${field.label} no tiene el formato correcto`;
    }

    return 'Campo inválido';
  }

  onSubmit(): void {
    if (this.dynamicForm.valid) {
      this.isSubmitting = true;
      const formData = this.dynamicForm.value;
      
      // Simular delay de envío
      setTimeout(() => {
        this.formSubmit.emit(formData);
        this.isSubmitting = false;
      }, 500);
    } else {
      // Marcar todos los campos como touched para mostrar errores
      Object.keys(this.dynamicForm.controls).forEach(key => {
        this.dynamicForm.get(key)?.markAsTouched();
      });
    }
  }

  // Métodos públicos para control externo
  public getFormValue(): any {
    return this.dynamicForm.value;
  }

  public isFormValid(): boolean {
    return this.dynamicForm.valid;
  }

  public resetForm(): void {
    this.dynamicForm.reset();
    this.buildForm();
  }

  public patchFormValue(value: any): void {
    this.dynamicForm.patchValue(value);
  }
}